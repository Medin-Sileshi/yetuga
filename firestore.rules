rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function hasRequiredFields() {
      let data = request.resource.data;

      // Common required fields for all account types
      let hasCommonFields = data.accountType is string
        && data.displayName is string
        && data.username is string
        && data.phoneNumber is string
        && data.profileImageUrl is string
        && data.onboardingCompleted is bool;

      // Check account type specific fields
      let isBusinessAccount = data.accountType == 'business';

      // Business account specific fields
      let hasBusinessFields = isBusinessAccount
        && data.establishedDate is timestamp
        && data.businessTypes is list;

      // Personal account specific fields
      let hasPersonalFields = !isBusinessAccount
        && data.birthday is timestamp
        && data.interests is list;

      return hasCommonFields && (hasBusinessFields || hasPersonalFields);
    }

    function isValidUsername() {
      let username = request.resource.data.username;
      return username.size() >= 2
        && username.size() <= 15
        && username.matches('^[a-z0-9_]+$');  // Updated to allow underscores
    }

    function isUniqueUsername() {
      let username = request.resource.data.username;
      return !exists(/databases/$(database)/documents/users/$(request.auth.uid))
        || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.username == username;
    }

    // Function to validate follow data
    function isValidFollowData() {
      let data = request.resource.data;
      return data.keys().hasAll(['userId', 'displayName', 'username', 'followedAt']) &&
        data.userId is string && data.userId.size() > 0 &&
        data.displayName is string &&
        data.username is string &&
        data.followedAt is timestamp;
    }

    // Users collection
    match /users/{userId} {
      // Allow reading any user document for authenticated users
      // This is needed for displaying user information in event cards
      allow read: if isAuthenticated();

      // Allow querying for username availability - simplified rule
      allow list: if isAuthenticated();

      allow create: if isAuthenticated()
        && isOwner(userId)
        && hasRequiredFields()
        && isValidUsername()
        && isUniqueUsername();

      // Allow updating user document with standard fields or follow counts
      allow update: if isAuthenticated() && (
        // Owner can update their own profile with all required fields
        (isOwner(userId) && hasRequiredFields() && isValidUsername() && isUniqueUsername()) ||

        // Allow incrementing/decrementing followingCount when user follows/unfollows someone
        (isOwner(userId) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followingCount'])) ||

        // Allow incrementing/decrementing followersCount when someone follows/unfollows this user
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followersCount']))
      );

      allow delete: if false;  // Prevent user deletion through client

      // Following collection - users that this user follows
      match /following/{followedUserId} {
        allow read: if isAuthenticated();

        // Only the user can modify their own following list
        allow create: if isAuthenticated() &&
                       isOwner(userId) &&
                       followedUserId != userId && // Can't follow yourself
                       isValidFollowData() &&
                       request.resource.data.userId == followedUserId; // Ensure correct ID

        allow delete: if isAuthenticated() && isOwner(userId);
      }

      // Followers collection - users who follow this user
      match /followers/{followerUserId} {
        allow read: if isAuthenticated();

        // Allow a user to add themselves to another user's followers list
        allow create: if isAuthenticated() &&
                       isOwner(followerUserId) &&
                       followerUserId != userId && // Can't follow yourself
                       isValidFollowData() &&
                       request.resource.data.userId == followerUserId; // Ensure correct ID

        // Allow a user to remove themselves from another user's followers list
        allow delete: if isAuthenticated() && isOwner(followerUserId);
      }
    }

    // Events collection
    match /events/{eventId} {
      // Allow reading events
      allow read: if isAuthenticated();

      // Allow creating events
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.activityType is string &&
        request.resource.data.inquiry is string &&
        request.resource.data.date is timestamp &&
        request.resource.data.time is map &&
        request.resource.data.isPrivate is bool &&
        request.resource.data.createdAt is timestamp &&
        (!request.resource.data.keys().hasAny(['attendeeLimit']) || request.resource.data.attendeeLimit is int);

      // Allow updating own events
      allow update: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Allow updating likedBy and joinedBy arrays for any authenticated user
      allow update: if isAuthenticated() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likedBy', 'joinedBy']);

      // Allow deleting own events
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Chat subcollection
      match /chat/{messageId} {
        // Allow reading chat messages if user is authenticated
        allow read: if isAuthenticated();

        // Allow creating chat messages if user is authenticated and senderId matches auth.uid
        allow create: if isAuthenticated() && request.resource.data.senderId == request.auth.uid;

        // Only allow the sender to update or delete their own messages
        allow update, delete: if isAuthenticated() && resource.data.senderId == request.auth.uid;
      }
    }

    // Notifications collection
    match /notifications/{notificationId} {
      // Allow reading notifications addressed to the current user or sent by the current user
      allow read: if isAuthenticated() &&
        (resource.data.userId == request.auth.uid || resource.data.senderId == request.auth.uid);

      // Allow listing notifications for the current user
      allow list: if isAuthenticated() &&
        request.query.limit <= 100 &&
        ((request.query.filters[0].fieldPath == 'userId' &&
          request.query.filters[0].op == '==' &&
          request.query.filters[0].value == request.auth.uid) ||
         (request.query.filters[0].fieldPath == 'senderId' &&
          request.query.filters[0].op == '==' &&
          request.query.filters[0].value == request.auth.uid) ||
         (request.query.filters[0].fieldPath == 'eventId'));

      // Allow creating notifications
      allow create: if isAuthenticated() &&
        request.resource.data.senderId == request.auth.uid;

      // Allow updating notifications addressed to the current user
      // or sent by the current user
      allow update: if isAuthenticated() &&
        (resource.data.userId == request.auth.uid ||
         resource.data.senderId == request.auth.uid);

      // Allow deleting notifications addressed to the current user
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
    }

    // Default deny
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
